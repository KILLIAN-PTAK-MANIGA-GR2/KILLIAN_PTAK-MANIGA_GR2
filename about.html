<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contact - PORTFOLIO</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Poppins', sans-serif;
        }

        .logo {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .logo img {
            display: block;
            height: 300px;
            width: auto;
        }

        nav {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        nav a {
            margin: 0 15px;
            text-decoration: none;
            font-size: 18px;
            color: white; /* Choisissez une couleur visible sur la vidéo */
        }

        /* Vidéo en dessous de la navigation */
        .video-container {
            width: 100%;
            height: 300px; /* Hauteur fixe pour la vidéo */
            margin-top: 0px; /* Espacement avant la vidéo */
            margin-bottom: 60px;
        }

        video {
            width: 100%; /* La vidéo prend toute la largeur */
            height: 100%; /* La vidéo prend toute la hauteur du conteneur */
            object-fit: cover; /* Remplit l'espace sans déformer l'image */
        }

        /* Ajouter du contenu sous la vidéo (facultatif) */
        .content {
            padding: 20px;
            text-align: center;
        }
    </style>
</head>
<body>

    <!-- En-tête avec logo et navigation -->
    <header>
        <div class="logo">
            <a href="index.html">
                <img src="port-removebg-preview.png" alt="Logo">
            </a>
        </div>
        <nav>
            <a href="index.html">Home</a>
            <a href="about.html">About</a>
            <a href="contact.html">Contact</a>
        </nav>
    </header>
    <div class="video-container">
        <video src="C:\Users\killi\Downloads\IIM HTML gr2\0001-0080.mp4" autoplay loop muted></video>
    </div>
    <head>
        <style>
            /* Ajuster la taille et rogner la vidéo */
            video {
                width: 100%;          /* Largeur du conteneur */
                height: 350px;        /* Hauteur fixe pour rognage */
                object-fit: cover;    /* Remplit et rogne la vidéo */
            }
        </style>
    </head> 
    </div>
</body>
</html>














<!DOCTYPE html>
<html lang="fr">

<head>
    <main id="aboutUs">
        <h2>Quantum Eclipse</h2>
    </main>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders</title>
    <style>
        /* Style de base pour le corps de la page */
        body { 
            margin: 100; 
            overflow-y: auto; 
            font-family: Arial, sans-serif; 
            display: flex; 
            flex-direction: column; /* Affiche tout en colonne */
            align-items: center; 
            height: 100vh; 
        }

        /* Style pour la barre d'infos */
        .info-bar {
            display: flex;
            flex-direction: row; /* Affiche les éléments horizontalement */
            justify-content: space-around;
            width: 100%;
            padding: 10px;
            background-color: #333;
            color: white;
        }

        #controls {
            margin-top: 20px;
            margin-bottom: 4px;
        }

        #gameCanvas {
            border: 1px solid black;
            width: 50%; /* Ajuste la largeur à 100% de l'écran */
            height: calc(70vh - 140px); /* Ajuste la hauteur en fonction de la hauteur de l'écran moins la barre d'infos et les contrôles */
            margin-bottom: 50px; /* Ajoute une marge de 50px en bas */
            box-sizing: border-box;
            padding-bottom: 0px;

            /* Ajoutez ces lignes pour l'image de fond */
            background-image: url('espace-animated.gif'); /* Remplacez par le chemin de votre image */
            background-size: cover; /* L'image couvrira toute la surface */
            background-position: center; /* Centrer l'image */
            background-repeat: no-repeat; /* Empêche la répétition de l'image */
        }
        #gameContainer {
            width: 100%;
            height: calc(100vh - 140px); /* Ajuste la hauteur en fonction de la hauteur de l'écran moins la barre d'infos, les contrôles et la marge */
            padding-bottom: 50px; /* Ajoute une marge de 50px en bas */
            box-sizing: border-box; /* Inclut le padding dans la hauteur totale */
        }

    </style>
</head>
<body>
    <div class="info-bar">
        <div id="score">Score: 0</div>
        <div id="lives">Vies: 3</div>
        <div id="enemiesLeft">Ennemis: 0</div>
        <div id="time">Temps: 0s</div>
    </div>
    <div id="controls">
        <button id="startButton">Commencer</button>
        <button id="stopButton">Arrêter</button>
        <button id="restartButton">Recommencer</button>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>






    
  <script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Variables du joueur, ennemis et balles
const player = { x: canvas.width / 2 - 25, y: canvas.height - 60, width: 50, height: 50, collisionWidth: 130, collisionHeight: 130, speed: 5, dx: 0, dy: 0, lives: 3, image: new Image() };
player.collisionWidth = 130;  // Augmente la largeur de la collision
player.collisionHeight = 130; // Ajuste la hauteur de la collision
const bullets = [];
const enemyBullets = [];
const enemies = [];
let score = 0;
let gameTime = 0;
let enemySpeedIncrement = 1;
let isGameRunning = false;
let gameInterval;
let enemySpawnInterval = 5000;
// Lorsque tu dessines la collision, assure-toi qu'elle est bien centrée
function drawPlayerCollision() {
    const scaleFactor = getScaleFactor();  // Récupérer le facteur d'échelle
    const imageWidth = 130 * scaleFactor;  // Appliquer l'échelle à la largeur de l'image
    const imageHeight = 130 * scaleFactor; // Appliquer l'échelle à la hauteur de l'image

    // Calculer la position de la collision (sans décalage supplémentaire)
    const centeredX = player.x; // La position X du joueur
    const centeredY = player.y; // La position Y du joueur

    // Dessiner la zone de collision (la boîte rouge)

}

// Variables de taille de base
const baseEnemyWidth = 40;
const baseEnemyHeight = 40;
const basePlayerWidth = 50;
const basePlayerHeight = 50;

// Ajuste la taille du canvas en fonction de la fenêtre
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    adaptGameElements();
}

// Calcul du facteur d'échelle basé sur la largeur du canvas
function getScaleFactor() {
    const referenceWidth = 800; // Largeur de référence pour l'échelle
    const scaleFactor = Math.min(canvas.width / referenceWidth, canvas.height / referenceWidth);
    return Math.max(scaleFactor, 0.5); // Limite le facteur d'échelle minimum à 0.5 pour que les éléments ne deviennent pas trop petits
}

// Adapter les dimensions du joueur
function adaptPlayer() {
    const scaleFactor = getScaleFactor();
    player.width = basePlayerWidth * scaleFactor;
    player.height = basePlayerHeight * scaleFactor;
    player.speed = 5 * scaleFactor; // Ajuste la vitesse en fonction du facteur d'échelle
    player.x = canvas.width / 2 - player.width / 2;
    player.y = canvas.height - player.height - 10;

    // Ajuste les dimensions de la zone de collision pour correspondre à la taille de l'image
    const imageWidth = 130 * scaleFactor;
    const imageHeight = 130 * scaleFactor;

    player.collisionWidth = imageWidth;
    player.collisionHeight = imageHeight;
}

// Adapter les dimensions des ennemis
function adaptEnemies() {
    const scaleFactor = getScaleFactor();
    enemies.forEach(enemy => {
        enemy.width = baseEnemyWidth * scaleFactor;
        enemy.height = baseEnemyHeight * scaleFactor;
        enemy.dy = Math.max(1, enemySpeedIncrement * scaleFactor); // Ajuster la vitesse en fonction du facteur d'échelle
    });
}

// Adapter les dimensions des balles
function adaptBullets() {
    const scaleFactor = getScaleFactor();
    bullets.forEach(bullet => {
        bullet.width = 5 * scaleFactor;
        bullet.height = 10 * scaleFactor;
        bullet.speed = 7 * scaleFactor;
    });

    enemyBullets.forEach(bullet => {
        bullet.width = 5 * scaleFactor;
        bullet.height = 10 * scaleFactor;
        bullet.speed = 5 * scaleFactor;
    });
}

const playerFrames = [
    new Image(), // Frame 1
    new Image(), // Frame 2
    new Image(), // Frame 3
    // Ajoutez plus de frames si nécessaire
];

playerFrames[0].src = 'vaiseau player principale 1.png'; // Remplacer avec le chemin de votre image de frame
playerFrames[1].src = 'vaiseau player principale 1.png';
playerFrames[2].src = 'vaiseau player flame2.png';

let currentFrame = 0;
let frameRate = 0.1; // Fréquence des frames par seconde

// Ajoutez une variable pour l'image GIF d'explosion
const explosionGif = new Image();
explosionGif.src = 'vaiseau player princ111ipale 1.gif'; // Remplacez par le chemin de votre GIF d'explosion
let isExploding = false; 

// Fonction pour dessiner le joueur avec l'image
function drawPlayer() {
    const scaleFactor = getScaleFactor();  // Récupérer le facteur d'échelle
    const imageWidth = 130 * scaleFactor;  // Largeur de l'image du joueur
    const imageHeight = 130 * scaleFactor; // Hauteur de l'image du joueur

    const frameIndex = Math.floor(currentFrame);  // Frame actuelle du joueur
    const centeredX = player.x; // Position X de l'image du joueur
    const centeredY = player.y; // Position Y de l'image du joueur

    if (player.lives > 0) {
        const frameIndex = Math.floor(currentFrame);
        ctx.drawImage(playerFrames[frameIndex], centeredX, centeredY, imageWidth, imageHeight);
    } else if (!isExploding) {
        // Déclencher l'explosion
        isExploding = true;
        ctx.drawImage(explosionGif, centeredX, centeredY, imageWidth, imageHeight);

        // Arrêter le jeu après un court délai (la durée du GIF)
        setTimeout(() => {
            isGameRunning = false;
            cancelAnimationFrame(gameInterval); // Arrête l'animation
        }, 1000); // Ajustez la durée en fonction de la durée de l'animation du GIF
    }
}


// Mettre à jour les frames de l'animation du joueur
function updatePlayerFrame() {
    currentFrame += frameRate;
    if (currentFrame >= playerFrames.length) {
        currentFrame = 0; // Redémarre l'animation
    }

    drawPlayer();
}

// Animation principale
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    updatePlayerFrame();
    requestAnimationFrame(animate);
}

// Démarrer l'animation
animate();



// Dessiner les balles du joueur avec forme arrondie
function drawBullets() {
    ctx.fillStyle = 'blue'; // Choisir la couleur de la balle
    bullets.forEach(bullet => {
        const radius = bullet.width / 2;  // Le rayon est la moitié de la largeur
        const centerX = bullet.x + radius;  // Position x du centre de la balle
        const centerY = bullet.y + radius;  // Position y du centre de la balle

        // Dessiner un cercle pour la balle
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);  // Crée un cercle complet
        ctx.fill();
    });
}

// Fonction pour dessiner la zone de collision de l'ennemi
function drawEnemyCollision(enemy) {
    const scaleFactor = getScaleFactor();  // Facteur d'échelle pour redimensionner l'ennemi

    // Calcul des dimensions de l'image redimensionnée
    const imageWidth = 85 * scaleFactor;
    const imageHeight = 85 * scaleFactor;

    // Si enemy.x et enemy.y sont le coin supérieur gauche de l'image :
    const topLeftX = enemy.x;
    const topLeftY = enemy.y;

    // Dessiner la zone de collision autour de l'ennemi
}

// Dessiner les balles des ennemis
function drawEnemyBullets() {
    ctx.fillStyle = 'purple';
    enemyBullets.forEach(bullet => {
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
    });
}

const enemyFrames = [
    new Image(),
    new Image(),
    new Image(),
    new Image(),
    new Image(),
];

enemyFrames[0].src = 'vaiseau spacial ennemie principale.png';
enemyFrames[1].src = 'vaiseau spacial ennemie principale.png';
enemyFrames[2].src = 'vaiseau spacial ennemie principale.png';
enemyFrames[3].src = 'vaiseau spacial ennemie principale.png';
enemyFrames[4].src = 'vaiseau spacial ennemie flame.png';

enemyFrames.forEach((image, index) => {
    image.onload = () => console.log(`Image ennemie ${index + 1} chargée avec succès.`);
    image.onerror = () => console.error(`Impossible de charger l’image ennemie ${index + 1}.`);
});

enemyFrames[0].src = 'vaiseau spacial ennemie principale.png';
enemyFrames[0].onerror = () => {
    console.error('Impossible de charger l’image ennemie 1 : vaiseau spacial ennemie principale.png');
};
enemyFrames[0].onload = () => {
    console.log('Image ennemie 1 chargée avec succès.');
};
enemyFrames[1].onload = () => {
    console.log('Image ennemie 2 chargée avec succès.');
};

function drawEnemies() {
    enemies.forEach((enemy) => {
        const scaleFactor = getScaleFactor(); // Récupérer le facteur d'échelle actuel
        const imageWidth = 85 * scaleFactor;  // Applique l'échelle à la largeur de l'image
        const imageHeight = 85 * scaleFactor;  

        // Utiliser une image aléatoire parmi les images d'ennemis (ou choisir une image spécifique selon l'ennemi)
        const frameIndex = Math.floor(Math.random() * enemyFrames.length); // Choisir une image aléatoire
        ctx.drawImage(enemyFrames[frameIndex], enemy.x, enemy.y, imageWidth, imageHeight);
    
    });
}
function createEnemy() {
    const scaleFactor = getScaleFactor(); // Obtenir le facteur d'échelle actuel
    const enemyWidth = baseEnemyWidth * scaleFactor; // Calculer la largeur de l'ennemi avec l'échelle
    const enemyHeight = baseEnemyHeight * scaleFactor; // Calculer la hauteur de l'ennemi avec l'échelle

    const x = Math.random() * (canvas.width - enemyWidth); // Position x aléatoire
    const y = -enemyHeight; // Position y initiale au-dessus du canvas

    // Créer un nouvel ennemi
    enemies.push({ x, y, width: enemyWidth, height: enemyHeight, dx: 0, dy: Math.max(1, enemySpeedIncrement * scaleFactor) });
    document.getElementById('enemiesLeft').innerText = `Ennemis: ${enemies.length}`;
    enemySpeedIncrement += 0.1; // Augmenter la vitesse des ennemis avec le temps
}


// Mouvements des éléments
function movePlayer() {
    player.x += player.dx;
    player.y += player.dy;

    // Garder le joueur à l'intérieur du canvas
    if (player.x < 0) player.x = 0;
    if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    if (player.y < 0) player.y = 0;
    if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
}

function moveBullets() {
    bullets.forEach((bullet, index) => {
        bullet.y -= bullet.speed;  // Déplacement de la balle vers le haut
        if (bullet.y < 0) bullets.splice(index, 1);  // Supprimer la balle si elle sort de l'écran
    });
}


function moveEnemyBullets() {
    enemyBullets.forEach((bullet, index) => {
        bullet.y += bullet.speed;
        if (bullet.y > canvas.height) enemyBullets.splice(index, 1);
    });


}
// Vérification de collision avec les ennemis, en prenant en compte la zone de collision correcte
function checkPlayerEnemyCollision() {
    enemies.forEach((enemy, index) => {
        // Vérification de la collision avec la zone de collision
        if (
            player.x < enemy.x + enemy.width &&
            player.x + player.collisionWidth > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.collisionHeight > enemy.y
        ) {
            // Gestion de la collision
            enemies.splice(index, 1); // Supprime l'ennemi
            player.lives -= 1;         // Diminuer les vies du joueur
            document.getElementById('lives').innerText = `Vies: ${player.lives}`;
            if (player.lives <= 0) {
                alert('Game Over!');
                stopGame();
            }
        }
        
    });
}

function endGame() {
    if (player.lives <= 0) {
        alert('Game Over! Vous avez perdu.');
        resetGame();
    } else if (enemies.length === 0) {
        alert('Félicitations ! Vous avez gagné !');
        resetGame();
    }
}

// Mouvements des ennemis
function moveEnemies() {
    enemies.forEach((enemy, index) => {
        // Calculer la direction vers le joueur
        const deltaX = player.x + player.width / 2 - (enemy.x + enemy.width / 2);  // Horizontalement vers le joueur
        const deltaY = player.y + player.height / 2 - (enemy.y + enemy.height / 2);  // Verticalement vers le joueur
        
        // Calculer l'angle pour déterminer la direction du mouvement
        const angle = Math.atan2(deltaY, deltaX); // L'angle entre l'ennemi et le joueur
        const speed = 3; // Vitesse de déplacement vers le joueur (ajustable)
        const downwardSpeed = 1; // Vitesse de descente continue de l'ennemi (ajustable)
        
        // Mouvement de l'ennemi
        enemy.x += Math.cos(angle) * speed;  // Suivi horizontal vers le joueur
        enemy.y += downwardSpeed;  // Descente continue vers le bas

        // Les ennemis tirent aléatoirement
        if (Math.random() < 0.01) {
            playSound(enemyHitSound);
            const scaleFactor = getScaleFactor();
            const enemyImageWidth = enemy.width;  // La largeur de l'image est égale à celle de l'ennemi redimensionné

            // Calculer les dimensions de la balle ennemie
            const bulletWidth = 10 * scaleFactor;
            const bulletHeight = 10 * scaleFactor;

            // Positionner la balle juste en dessous de l'ennemi, centré
            const centerX = enemy.x + (enemyImageWidth - bulletWidth) / 2;
            const bulletY = enemy.y + enemy.height;

            // Ajouter la balle ennemie
            enemyBullets.push({
                x: centerX, // Position x centrée
                y: bulletY, // Position y juste en dessous de l'ennemi
                width: bulletWidth,
                height: bulletHeight,
                speed: 2 * scaleFactor // Vitesse de la balle ennemie
            });
        }


        // Supprimer l'ennemi s'il sort de l'écran
        if (enemy.y > canvas.height) enemies.splice(index, 1);
    });
}




// Animation principale
function update() {
    if (!isGameRunning) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawPlayer();
    drawBullets();
    drawEnemyBullets();
    drawEnemies();
    movePlayer();
    moveBullets();
    moveEnemyBullets();
    moveEnemies();
    detectCollisions();
    checkPlayerEnemyCollision(); // Appel de la vérification des collisions joueur-ennemi
    requestAnimationFrame(update);
}


// Détecter les collisions
function detectCollisions() {
    bullets.forEach((bullet, bulletIndex) => {
        enemies.forEach((enemy, enemyIndex) => {
            if (
                bullet.x < enemy.x + enemy.width &&
                bullet.x + bullet.width > enemy.x &&
                bullet.y < enemy.y + enemy.height &&
                bullet.y + bullet.height > enemy.y
            ) {
                setTimeout(() => {
                    bullets.splice(bulletIndex, 1);
                    enemies.splice(enemyIndex, 1);
                    score += 1;
                    document.getElementById('score').innerText = `Score: ${score}`;
                    document.getElementById('enemiesLeft').innerText = `Ennemis: ${enemies.length}`;
                }, 0);
            }
        });
    });

    enemyBullets.forEach((bullet, bulletIndex) => {
        if (
            bullet.x < player.x + player.width &&
            bullet.x + bullet.width > player.x &&
            bullet.y < player.y + player.height &&
            bullet.y + bullet.height > player.y
        ) {
            setTimeout(() => {
                enemyBullets.splice(bulletIndex, 1);
                player.lives -= 1;
                document.getElementById('lives').innerText = `Vies: ${player.lives}`;
                if (player.lives <= 0) {
                    playSound(gameOverSound);
                    alert('Game Over!');
                    stopGame();
                }

            }, 0);
        }
    });
}

// Contrôles du jeu
function startGame() {
    if (!isGameRunning) {
        isGameRunning = true;
        
        // Démarrer l'intervalle de création d'ennemis
        gameInterval = setInterval(() => {
            createEnemy();
        }, enemySpawnInterval);

        // Démarrer le chronomètre du jeu
        gameTimeInterval = setInterval(() => {
            gameTime += 1;
            document.getElementById('time').innerText = `Temps: ${gameTime}s`;

            // Vérifier si le temps a atteint 60 secondes
            if (gameTime >= 60) {
                stopGame();
            }
        }, 1000); // L'intervalle est de 1 seconde

        update(); // Appeler la fonction pour mettre à jour l'état du jeu
    }
}

function stopGame() {
    isGameRunning = false;
    clearInterval(gameInterval);
    clearInterval(gameTimeInterval);
    // Optionnel : afficher un message final avec le temps écoulé
    alert(`Game Over! Temps total: ${gameTime}s`);
}

function restartGame() {
    document.location.reload();
}

// Calculer la largeur de l'image du joueur redimensionnée
function getPlayerImageWidth() {
    const scaleFactor = getScaleFactor();  // Récupère le facteur d'échelle actuel
    const imageWidth = 130 * scaleFactor;  // Largeur de l'image du joueur redimensionnée
    return imageWidth;
}

// Écouteurs d'événements
document.addEventListener('keydown', e => {
    if (e.key === 'd') player.dx = player.speed;
    if (e.key === 'q') player.dx = -player.speed;
    if (e.key === 'z') player.dy = -player.speed;
    if (e.key === 's') player.dy = player.speed;
    // Tirer des balles lorsque la barre d'espace est pressée
    if (e.key === ' ') {
        // Créer une balle pour le joueur avec une taille augmentée
        playSound(bulletSound);
        const scaleFactor = getScaleFactor();
        const bulletWidth = 15 * scaleFactor;  // Largeur de la balle, augmenté (exemple: 12)
        const bulletHeight = 15 * scaleFactor;  // Hauteur de la balle, augmentée (c'est un cercle donc hauteur = largeur)

        // Calculer le x pour centrer la balle par rapport à l'image du joueur
        const playerImageWidth = getPlayerImageWidth(); // Retourne la largeur réelle de l'image
        const centerX = player.x + (playerImageWidth / 2) - (bulletWidth / 2);

        bullets.push({
            x: centerX,
            y: player.y,  // Position y (juste au-dessus du joueur)
            width: bulletWidth,
            height: bulletHeight,
            speed: 7 * scaleFactor
        });
    }
});

// Charger des sons
const bulletSound = new Audio('tir joueur.mp3');
const enemyHitSound = new Audio('tir ennemie.mp3');
const gameOverSound = new Audio('game-over-arcade-6435.mp3');

// Jouer le son lors d'une action spécifique
function playSound(sound) {
    sound.currentTime = 0; // Revenir au début
    sound.play();
}



document.addEventListener('keyup', e => {
    if (['d', 'q'].includes(e.key)) player.dx = 0;
    if (['z', 's'].includes(e.key)) player.dy = 0;
});

document.addEventListener('keyup', e => {
    if (['d', 'q'].includes(e.key)) player.dx = 0;
    if (['z', 's'].includes(e.key)) player.dy = 0;
});

document.getElementById('startButton').addEventListener('click', startGame);
document.getElementById('stopButton').addEventListener('click', stopGame);
document.getElementById('restartButton').addEventListener('click', restartGame);

// Initialisation du canvas et des éléments
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

    </script>
</body>
<main id="aboutUs">
    <h2>À propos de nous</h2>
    <p>This page contains information about us.</p>
</main>

</html>
